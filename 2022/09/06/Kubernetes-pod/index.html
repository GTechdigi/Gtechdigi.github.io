<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Kubernetes-pod | Gtech</title><meta name="author" content="Gtechdigi"><meta name="copyright" content="Gtechdigi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="highlight: vs2015概述Pod 手动水平伸缩ReplicaSet 控制器负责维持指定数量的 Pod 实例始终正常运行。这指定的 Pod 实例数在声明的工作负载资源对象中指定，如Deployment等。 通常定义在 Deployment 的.spec.replicas字段中的 Pod 副本数是个静态值，如果需要对应用进行扩容，我们可以手动向 Kubernetes 发出命令对应用程序进">
<meta property="og:type" content="article">
<meta property="og:title" content="Kubernetes-pod">
<meta property="og:url" content="http://example.com/2022/09/06/Kubernetes-pod/index.html">
<meta property="og:site_name" content="Gtech">
<meta property="og:description" content="highlight: vs2015概述Pod 手动水平伸缩ReplicaSet 控制器负责维持指定数量的 Pod 实例始终正常运行。这指定的 Pod 实例数在声明的工作负载资源对象中指定，如Deployment等。 通常定义在 Deployment 的.spec.replicas字段中的 Pod 副本数是个静态值，如果需要对应用进行扩容，我们可以手动向 Kubernetes 发出命令对应用程序进">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.gtechdigi.cn/favicon.ico">
<meta property="article:published_time" content="2022-09-06T09:47:09.000Z">
<meta property="article:modified_time" content="2023-05-19T09:49:06.398Z">
<meta property="article:author" content="Gtechdigi">
<meta property="article:tag" content="Kubernetes">
<meta property="article:tag" content="pod">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.gtechdigi.cn/favicon.ico"><link rel="shortcut icon" href="https://www.gtechdigi.cn/favicon.ico"><link rel="canonical" href="http://example.com/2022/09/06/Kubernetes-pod/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Kubernetes-pod',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-19 17:49:06'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://www.gtechdigi.cn/favicon.ico" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.gtechdigi.cn/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Gtech"><img class="site-icon" src="https://www.gtechdigi.cn/_nuxt/img/logo.ae1c073.png"/></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.gtechdigi.cn/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Kubernetes-pod</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-06T09:47:09.000Z" title="发表于 2022-09-06 17:47:09">2022-09-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-19T09:49:06.398Z" title="更新于 2023-05-19 17:49:06">2023-05-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Kubernetes/">Kubernetes</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Kubernetes-pod"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><hr>
<h2 id="highlight-vs2015"><a href="#highlight-vs2015" class="headerlink" title="highlight: vs2015"></a>highlight: vs2015</h2><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="Pod-手动水平伸缩"><a href="#Pod-手动水平伸缩" class="headerlink" title="Pod 手动水平伸缩"></a>Pod 手动水平伸缩</h3><p>ReplicaSet 控制器负责维持指定数量的 Pod 实例始终正常运行。这指定的 Pod 实例数在声明的工作负载资源对象中指定，如<code>Deployment</code>等。</p>
<p>通常定义在 Deployment 的<code>.spec.replicas</code>字段中的 Pod 副本数是个静态值，如果需要对应用进行扩容，我们可以手动向 Kubernetes 发出命令对应用程序进行伸缩。我们可以根据业务的变化，提前做好准备，如在可预见的即将到来的电商促销活动之前对应用进行扩容，在促销活动结束后再对应用进行缩容。手动伸缩需要我们人类对应用程序进行观察和预测，然后决定扩容的数量。但是，手动伸缩的方式不适用于经常变更且需要不断适应的动态工作负载模式。</p>
<p>命令式手动伸缩</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale my-app --replicas=4</span><br></pre></td></tr></table></figure>

<h3 id="Pod-自动水平伸缩"><a href="#Pod-自动水平伸缩" class="headerlink" title="Pod 自动水平伸缩"></a>Pod 自动水平伸缩</h3><p>Kubernetes 提供了 Pod 自动水平伸缩（<code>HorizontalPodAutoscaler</code>，简称<code>HPA</code>）能力让我们定义可变的动态应用程序容量，容量不是固定不变的，可能会变大也可能会缩小，但是 Kubernetes 会确保有足够的容量来处理不同的负载情况。</p>
<p>以下示例定义了，当 Pod 的平均 cpu 使用率达到 50% 时触发水平扩展，但最大 Pod 运行数不超过 10 个。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: autoscaling/v2</span><br><span class="line">kind: HorizontalPodAutoscaler</span><br><span class="line">metadata:</span><br><span class="line">  name: my-app</span><br><span class="line">spec:</span><br><span class="line">  scaleTargetRef:        ①</span><br><span class="line">    apiVersion: apps/v1</span><br><span class="line">    kind: Deployment</span><br><span class="line">    name: my-app</span><br><span class="line">  minReplicas: 1         ②</span><br><span class="line">  maxReplicas: 10        ③</span><br><span class="line">  metrics:</span><br><span class="line">    - type: Resource     ④</span><br><span class="line">      resource:</span><br><span class="line">        name: cpu        ⑤</span><br><span class="line">        target:</span><br><span class="line">          type: Utilization</span><br><span class="line">          averageUtilization: 50</span><br></pre></td></tr></table></figure>

<p>① 声明了与此 HPA 相关联的 Deployment 的引用。<br>② 最小运行 Pod 副本数。<br>③ 最大运行 Pod 副本数。<br>④ 指定监控数据度量指标的类别为<code>Resource</code>。如 cpu 利用率是一个<code>Resource</code>类别的 metric 度量指标。度量指标类别还可选<code>ContainerResource</code>、<code>Pods</code>、<code>External</code>、<code>Object</code>等，详细描述可参考 Kubernetes 官方文档或源代码。<br>⑤ 声明理想状态下的 cpu 使用率，即已使用的 cpu 与请求的 cpu 资源百分比。假设 Pod 的<code>.spec.resources.requests.cpu</code>定义为 200m，那么当 cpu 平均使用超过 100m，即 50% 以上时则会触发 Pod 水平扩容。[1]</p>
<p>以上内容对是 HPA 的基本介绍， HPA 的使用并不是本文所要讲述的重点，本篇是对 HPA 控制器源代码的解析。篇幅略长，感谢您的耐心阅读。</p>
<p>HPA 作为 Kubernetes 的一种资源，每一种资源都有对应的控制器，控制器负责维持资源的状态始终与我们在资源对象中声明的期望状态一致，在这个维持状态一致的过程中即使发生了错误，控制器也会将该项工作重新加入工作队列，等待一下次重试处理，直到状态一致为止，这个过程，称之为<code>reconcile</code>（调协），本系统文章的核心也是围绕 HPA 的调协逻辑。</p>
<blockquote>
<p>提示：由于篇幅有限，为了方便阅读， Kubernetes 源代码摘取部分作了一些省略。省略的代码并不会影响对源码主要逻辑的理解，被省略的源码对应的位置会添加相应的注释。代码的引用也给出了在 Kubernetes项目中相对的路径。本篇文章基于<code>release-1.24</code>版本。</p>
</blockquote>
<h2 id="MetricsClient"><a href="#MetricsClient" class="headerlink" title="MetricsClient"></a>MetricsClient</h2><p>HPA 控制逻辑建立在相关的监控度量指标数据之上，所以需要通过<code>metrics client</code>来获取不同度量指标类别的监控数据。如 Pod 的<code>cpu</code>和<code>memory</code>的使用占比等。</p>
<h3 id="MetricsClient-接口定义"><a href="#MetricsClient-接口定义" class="headerlink" title="MetricsClient 接口定义"></a>MetricsClient 接口定义</h3><p>代码路径：pkg&#x2F;controller&#x2F;podautoscaler&#x2F;metrics&#x2F;interfaces.go</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// MetricsClient knows how to query a remote interface to retrieve container-level</span><br><span class="line">// resource metrics as well as pod-level arbitrary metrics</span><br><span class="line">type MetricsClient interface &#123;</span><br><span class="line"> // GetResourceMetric gets the given resource metric (and an associated oldest timestamp)</span><br><span class="line"> // for the specified named container in all pods matching the specified selector in the given namespace and when</span><br><span class="line"> // the container is an empty string it returns the sum of all the container metrics.</span><br><span class="line"> GetResourceMetric(ctx context.Context, resource v1.ResourceName, namespace string, selector labels.Selector, container string) (PodMetricsInfo, time.Time, error)</span><br><span class="line"></span><br><span class="line"> // GetRawMetric gets the given metric (and an associated oldest timestamp)</span><br><span class="line"> // for all pods matching the specified selector in the given namespace</span><br><span class="line"> GetRawMetric(metricName string, namespace string, selector labels.Selector, metricSelector labels.Selector) (PodMetricsInfo, time.Time, error)</span><br><span class="line"></span><br><span class="line"> // GetObjectMetric gets the given metric (and an associated timestamp) for the given</span><br><span class="line"> // object in the given namespace</span><br><span class="line"> GetObjectMetric(metricName string, namespace string, objectRef *autoscaling.CrossVersionObjectReference, metricSelector labels.Selector) (int64, time.Time, error)</span><br><span class="line"></span><br><span class="line"> // GetExternalMetric gets all the values of a given external metric</span><br><span class="line"> // that match the specified selector.</span><br><span class="line"> GetExternalMetric(metricName string, namespace string, selector labels.Selector) ([]int64, time.Time, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该接口大致声明了以下能力：</p>
<ul>
<li>获取 Resource、Pod 等相关度量指标</li>
<li>获取集群内部对象的相关度量指标</li>
<li>获取集群外部的相关度量指标</li>
</ul>
<p>源代码的注释描述得非常详细了，不多加赘述了。<code>自我吐槽：水平有限，翻译不出原汁原味(o^^o)。</code></p>
<h3 id="创建-metrics-客户端"><a href="#创建-metrics-客户端" class="headerlink" title="创建 metrics 客户端"></a>创建 metrics 客户端</h3><p>MetricsClient 的实现分别由三个具体的<code>metrics client</code>提供，它们与 MetricsClient 接口的能力描述相对应，各司其职，职责单一。<br>① MetricsV1beta1Client，用于和 API 组<code>metrics.k8s.io</code>提供的接口进行集成，获取集群内置度量指标的客户端，如 Pod 监控指标数据的获取等。<br>② CustomMetricsClient，自定义度量指标客户端。<br>③ ExternalMetricsClient，集群外部度量指标客户端。</p>
<p>代码路径：cmd&#x2F;kube-controller-manager&#x2F;app&#x2F;autoscaling.go</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func startHPAControllerWithRESTClient(ctx context.Context, controllerContext ControllerContext) (controller.Interface, bool, error) &#123;</span><br><span class="line"> clientConfig := controllerContext.ClientBuilder.ConfigOrDie(&quot;horizontal-pod-autoscaler&quot;)</span><br><span class="line"> hpaClient := controllerContext.ClientBuilder.ClientOrDie(&quot;horizontal-pod-autoscaler&quot;)</span><br><span class="line"> apiVersionsGetter := custom_metrics.NewAvailableAPIsGetter(hpaClient.Discovery())</span><br><span class="line">// ...省略部分代码</span><br><span class="line">// 创建 metrics 客户端</span><br><span class="line"> metricsClient := metrics.NewRESTMetricsClient(</span><br><span class="line">// ① 集群内置度量指标客户端 </span><br><span class="line">  resourceclient.NewForConfigOrDie(clientConfig),</span><br><span class="line">// ② 自定义度量指标客户端 </span><br><span class="line">  custom_metrics.NewForConfig(clientConfig, controllerContext.RESTMapper, apiVersionsGetter),</span><br><span class="line">// ③ 集群外部度量指标客户端    </span><br><span class="line">  external_metrics.NewForConfigOrDie(clientConfig),</span><br><span class="line"> )</span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HorizontalController"><a href="#HorizontalController" class="headerlink" title="HorizontalController"></a>HorizontalController</h2><p>HPA 控制器负责 Pod 自动水平伸缩逻辑的控制。</p>
<h3 id="创建-HPA-控制器"><a href="#创建-HPA-控制器" class="headerlink" title="创建 HPA 控制器"></a>创建 HPA 控制器</h3><p>创建<code>HorizontalController</code>并运行<code>Run</code>函数。<code>HPA</code>控制器需要依赖一些 API 和组件才能工作。<br>① Scale 对象客户端，用于查询和修改实现了<code>scale</code> 子资源对象的<code>scales</code>，可理解成 Pod 要伸缩的实例副本数。</p>
<p><code>Scale</code> 定义的相关代码位于 staging&#x2F;src&#x2F;k8s.io&#x2F;api&#x2F;autoscaling&#x2F;v1&#x2F;types.go</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Scale represents a scaling request for a resource.</span><br><span class="line">type Scale struct &#123;</span><br><span class="line"> metav1.TypeMeta </span><br><span class="line"> metav1.ObjectMeta </span><br><span class="line"> Spec ScaleSpec </span><br><span class="line"> Status ScaleStatus </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ScaleSpec struct &#123;</span><br><span class="line"> // desired number of instances for the scaled object.</span><br><span class="line"> Replicas int32</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>② HorizontalPodAutoscalersGetter，定义了 HPA 资源对象的<code>Create</code>、<code>Update</code>、<code>Delete</code>、<code>Get</code>、<code>List</code>、<code>Watch</code>等相关方法。<br>③ Metrics 客户端，前文已重点介绍过，不再赘述。<br>④ HPA Informer，用于监听 HPA 对象的新增、修改、删除变更事件并且维护了一个本地内存缓存查询列表。<br>⑤ Pod Informer，用于监听 Pod 对象的新增、修改、删除变更事件并且维护了一个本地内存缓存查询列表。</p>
<p>代码路径：cmd&#x2F;kube-controller-manager&#x2F;app&#x2F;autoscaling.go</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">func startHPAControllerWithMetricsClient(ctx context.Context, controllerContext ControllerContext, metricsClient metrics.MetricsClient) (controller.Interface, bool, error) &#123;</span><br><span class="line"> hpaClient := controllerContext.ClientBuilder.ClientOrDie(&quot;horizontal-pod-autoscaler&quot;)</span><br><span class="line"> hpaClientConfig := controllerContext.ClientBuilder.ConfigOrDie(&quot;horizontal-pod-autoscaler&quot;)</span><br><span class="line"> scaleKindResolver := scale.NewDiscoveryScaleKindResolver(hpaClient.Discovery())</span><br><span class="line"> scaleClient, err := scale.NewForConfig(hpaClientConfig, controllerContext.RESTMapper, dynamic.LegacyAPIPathResolverFunc, scaleKindResolver)</span><br><span class="line">// ...省略部分代码</span><br><span class="line"> go podautoscaler.NewHorizontalController(</span><br><span class="line">// v1.CoreV1Interface  </span><br><span class="line">// 参考 &quot;k8s.io/client-go/kubernetes/typed/core/v1&quot; 包</span><br><span class="line">  hpaClient.CoreV1(),</span><br><span class="line">// ① Scale 客户端</span><br><span class="line">  scaleClient,</span><br><span class="line">// ② HorizontalPodAutoscalersGetter</span><br><span class="line">  hpaClient.AutoscalingV2(),</span><br><span class="line">// RESTMapper 用于处理 GroupVersionResource 与 GroupVersionKind 之间的映射关系    </span><br><span class="line">  controllerContext.RESTMapper,</span><br><span class="line">// ③ Metrics 客户端</span><br><span class="line">  metricsClient,</span><br><span class="line">// ④ HPA Informer</span><br><span class="line">  controllerContext.InformerFactory.Autoscaling().V2().HorizontalPodAutoscalers(),</span><br><span class="line">// ⑤ Pod Informer</span><br><span class="line">  controllerContext.InformerFactory.Core().V1().Pods(),</span><br><span class="line">// ...</span><br><span class="line"> ).Run(ctx)</span><br><span class="line"> return nil, true, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⑥ Pod 副本数计算器，这是一个非常重要的角色，它的职责是根据当前采集到的相关度量指标监控数据和 HPA 声明的理想资源使用率经过一系列运算得到 Pod 的容量<code>scale</code>，以此来决策 Pod 副本容量的伸缩。</p>
<p>代码位置：pkg&#x2F;controller&#x2F;podautoscaler&#x2F;horizontal.go</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 注：篇幅有限，省略了参数定义部分代码</span><br><span class="line">// NewHorizontalController creates a new HorizontalController.</span><br><span class="line">func NewHorizontalController() *HorizontalController &#123;</span><br><span class="line"> hpaController := &amp;HorizontalController&#123;&#125;</span><br><span class="line">// ...省略部分代码</span><br><span class="line">// ⑥ Pod 副本数计算器</span><br><span class="line"> replicaCalc := NewReplicaCalculator(</span><br><span class="line">  metricsClient,</span><br><span class="line">  hpaController.podLister,</span><br><span class="line">  tolerance,</span><br><span class="line">  cpuInitializationPeriod,</span><br><span class="line">  delayOfInitialReadinessStatus,</span><br><span class="line"> )</span><br><span class="line"> hpaController.replicaCalc = replicaCalc</span><br><span class="line"> return hpaController</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="启动-HPA-控制器"><a href="#启动-HPA-控制器" class="headerlink" title="启动 HPA 控制器"></a>启动 HPA 控制器</h3><p>启动 HPA 控制器，监听 HPA 对象变更事件并进行同步。</p>
<p>代码位置：pkg&#x2F;controller&#x2F;podautoscaler&#x2F;horizontal.go</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// Run begins watching and syncing.</span><br><span class="line">func (a *HorizontalController) Run(ctx context.Context) &#123;</span><br><span class="line">   defer utilruntime.HandleCrash()</span><br><span class="line">   defer a.queue.ShutDown()</span><br><span class="line"></span><br><span class="line">   klog.Infof(&quot;Starting HPA controller&quot;)</span><br><span class="line">   defer klog.Infof(&quot;Shutting down HPA controller&quot;)</span><br><span class="line"></span><br><span class="line">   if !cache.WaitForNamedCacheSync(&quot;HPA&quot;, ctx.Done(), a.hpaListerSynced, a.podListerSynced) &#123;</span><br><span class="line">      return</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // start a single worker (we may wish to start more in the future)</span><br><span class="line">   go wait.UntilWithContext(ctx, a.worker, time.Second)</span><br><span class="line"></span><br><span class="line">   &lt;-ctx.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数-woker"><a href="#函数-woker" class="headerlink" title="函数 woker"></a>函数 woker</h3><p>不停地从工作队列里取出相对应的数据进行处理，直到工作队列<code>shutdown</code>关闭为止。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">func (a *HorizontalController) worker(ctx context.Context) &#123;</span><br><span class="line">// 不停地从工作队列里取出相对应的数据进行处理</span><br><span class="line"> for a.processNextWorkItem(ctx) &#123;</span><br><span class="line"> &#125;</span><br><span class="line"> klog.Infof(&quot;horizontal pod autoscaler controller worker shutting down&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *HorizontalController) processNextWorkItem(ctx context.Context) bool &#123;</span><br><span class="line"> key, quit := a.queue.Get()</span><br><span class="line">// 工作队列关闭，终止 for 循环</span><br><span class="line"> if quit &#123;</span><br><span class="line">  return false</span><br><span class="line"> &#125;</span><br><span class="line"> defer a.queue.Done(key)</span><br><span class="line"></span><br><span class="line"> deleted, err := a.reconcileKey(ctx, key.(string))</span><br><span class="line"> if err != nil &#123;</span><br><span class="line">  utilruntime.HandleError(err)</span><br><span class="line"> &#125;</span><br><span class="line"> if !deleted &#123;</span><br><span class="line">  a.queue.AddRateLimited(key)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数-reconcileKey"><a href="#函数-reconcileKey" class="headerlink" title="函数 reconcileKey"></a>函数 reconcileKey</h3><p>工作队列中的数据为 HPA 对象的 namespace 和 name 组合而成的字符串<code>key</code>，对应集群中某个 HPA 对象。<br>① 将 key 拆解为 namespace 和 name。<br>② 获取集群中相对应的 HPA 对象。<br>③ 如果 HPA 对象已经被删除，清理其相关联的一些数据，释放资源。<br>④ 对 HPA 对象进行调协。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func (a *HorizontalController) reconcileKey(ctx context.Context, key string) (deleted bool, err error) &#123;</span><br><span class="line">// ① 将 key 拆解为 namespace 和 name</span><br><span class="line"> namespace, name, err := cache.SplitMetaNamespaceKey(key)</span><br><span class="line"> if err != nil &#123;</span><br><span class="line">  return true, err</span><br><span class="line"> &#125;</span><br><span class="line">// ② 获取集群中相对应的 HPA 对象</span><br><span class="line"> hpa, err := a.hpaLister.HorizontalPodAutoscalers(namespace).Get(name)</span><br><span class="line">// ③ 如果 HPA 对象已经被删除，清理其相关联的一些数据，释放资源  </span><br><span class="line"> if errors.IsNotFound(err) &#123;</span><br><span class="line">  klog.Infof(&quot;Horizontal Pod Autoscaler %s has been deleted in %s&quot;, name, namespace)</span><br><span class="line">  delete(a.recommendations, key)</span><br><span class="line">  delete(a.scaleUpEvents, key)</span><br><span class="line">  delete(a.scaleDownEvents, key)</span><br><span class="line">  return true, nil</span><br><span class="line"> &#125;</span><br><span class="line"> if err != nil &#123;</span><br><span class="line">  return false, err</span><br><span class="line"> &#125;</span><br><span class="line">// ④ 对 HPA 对象进行调协</span><br><span class="line"> return false, a.reconcileAutoscaler(ctx, hpa, key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数-reconcileAutoscaler"><a href="#函数-reconcileAutoscaler" class="headerlink" title="函数 reconcileAutoscaler"></a>函数 reconcileAutoscaler</h3><p>该函数是 HPA 调协逻辑的整体描述，即自动扩缩容的主体实现，代码拆解如下：<br>① 获取 HPA 关联目标的当前 scale， 即 pod 副本数。<br>以上述 HPA YAML 示例来讲，即获取和 HPA 位于同一 namespace 下的 name 为 my-app 的 Deployment 对象。<br>② 边界值处理。</p>
<ul>
<li>目标对象当前 pod 副本数为 0 ，对此目标对象禁用自动伸缩。</li>
<li>目标对象当前副本数小于 HPA 定义的最小副本数，调整副本数为 HPA 最小副本数。</li>
<li>目标对象当前副本数大于 HPA 定义的最大副本数，调整副本数为 HPA 最大副本数。</li>
</ul>
<p>③ 根据监控数据度量指标计算出调整后的 scale，即期望的 pod 副本数。<br>④ 对上一步计算出来的期望 pod 副本数做进一步调整以确定最终的期望副本数。<br>上述示例中并未指定 <code>.spec.behavior</code>字段相关配置，即对目标对象的容量伸缩运用默认的规则（<code>HPAScalingRules</code>），将在文章后面进行介绍。<br>⑤ 更新目标对象对应的 scale。<br>⑥ 更新 HPA 对象的状态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">func (a *HorizontalController) reconcileAutoscaler(ctx context.Context, hpaShared *autoscalingv2.HorizontalPodAutoscaler, key string) error &#123;</span><br><span class="line"> // make a copy so that we never mutate the shared informer cache (conversion can mutate the object)</span><br><span class="line"> hpa := hpaShared.DeepCopy()</span><br><span class="line"> hpaStatusOriginal := hpa.Status.DeepCopy()</span><br><span class="line">// HPA 关联目标对象的引用</span><br><span class="line"> reference := fmt.Sprintf(&quot;%s/%s/%s&quot;, hpa.Spec.ScaleTargetRef.Kind, hpa.Namespace, hpa.Spec.ScaleTargetRef.Name)</span><br><span class="line"> targetGV, err := schema.ParseGroupVersion(hpa.Spec.ScaleTargetRef.APIVersion)</span><br><span class="line">// ...省略 err 处理相关代码</span><br><span class="line"> targetGK := schema.GroupKind&#123;</span><br><span class="line">  Group: targetGV.Group,</span><br><span class="line">  Kind:  hpa.Spec.ScaleTargetRef.Kind,</span><br><span class="line"> &#125;</span><br><span class="line">// 获取 GroupVersionResource 和 GroupVersionKind 的映射关系</span><br><span class="line"> mappings, err := a.mapper.RESTMappings(targetGK)</span><br><span class="line">// ...</span><br><span class="line">// ① 获取 HPA 关联目标的当前 scale    </span><br><span class="line"> scale, targetGR, err := a.scaleForResourceMappings(ctx, hpa.Namespace, hpa.Spec.ScaleTargetRef.Name, mappings)</span><br><span class="line">// ...</span><br><span class="line"> setCondition(hpa, autoscalingv2.AbleToScale, v1.ConditionTrue, &quot;SucceededGetScale&quot;, &quot;the HPA controller was able to get the target&#x27;s current scale&quot;)</span><br><span class="line"> currentReplicas := scale.Spec.Replicas</span><br><span class="line"> a.recordInitialRecommendation(currentReplicas, key)</span><br><span class="line"></span><br><span class="line"> var (</span><br><span class="line">  metricStatuses        []autoscalingv2.MetricStatus</span><br><span class="line">  metricDesiredReplicas int32</span><br><span class="line">  metricName            string</span><br><span class="line"> )</span><br><span class="line"></span><br><span class="line"> desiredReplicas := int32(0)</span><br><span class="line"> rescaleReason := &quot;&quot;</span><br><span class="line"></span><br><span class="line"> var minReplicas int32</span><br><span class="line"></span><br><span class="line"> if hpa.Spec.MinReplicas != nil &#123;</span><br><span class="line">  minReplicas = *hpa.Spec.MinReplicas</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">  minReplicas = 1</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> rescale := true</span><br><span class="line"></span><br><span class="line"> if scale.Spec.Replicas == 0 &amp;&amp; minReplicas != 0 &#123; // ② 边界值处理</span><br><span class="line">  // Autoscaling is disabled for this resource</span><br><span class="line">  desiredReplicas = 0</span><br><span class="line">  rescale = false</span><br><span class="line">  setCondition(hpa, autoscalingv2.ScalingActive, v1.ConditionFalse, &quot;ScalingDisabled&quot;, &quot;scaling is disabled since the replica count of the target is zero&quot;)</span><br><span class="line"> &#125; else if currentReplicas &gt; hpa.Spec.MaxReplicas &#123; // ② 边界值处理</span><br><span class="line">  rescaleReason = &quot;Current number of replicas above Spec.MaxReplicas&quot;</span><br><span class="line">  desiredReplicas = hpa.Spec.MaxReplicas</span><br><span class="line"> &#125; else if currentReplicas &lt; minReplicas &#123; // ② 边界值处理</span><br><span class="line">  rescaleReason = &quot;Current number of replicas below Spec.MinReplicas&quot;</span><br><span class="line">  desiredReplicas = minReplicas</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">  var metricTimestamp time.Time</span><br><span class="line">// ③ 计算出调整后的 scale    </span><br><span class="line">  metricDesiredReplicas, metricName, metricStatuses, metricTimestamp, err = a.computeReplicasForMetrics(ctx, hpa, scale, hpa.Spec.Metrics)</span><br><span class="line">  if err != nil &#123;</span><br><span class="line">   a.setCurrentReplicasInStatus(hpa, currentReplicas)</span><br><span class="line">   if err := a.updateStatusIfNeeded(ctx, hpaStatusOriginal, hpa); err != nil &#123;</span><br><span class="line">    utilruntime.HandleError(err)</span><br><span class="line">   &#125;</span><br><span class="line">   a.eventRecorder.Event(hpa, v1.EventTypeWarning, &quot;FailedComputeMetricsReplicas&quot;, err.Error())</span><br><span class="line">   return fmt.Errorf(&quot;failed to compute desired number of replicas based on listed metrics for %s: %v&quot;, reference, err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  klog.V(4).Infof(&quot;proposing %v desired replicas (based on %s from %s) for %s&quot;, metricDesiredReplicas, metricName, metricTimestamp, reference)</span><br><span class="line"></span><br><span class="line">  rescaleMetric := &quot;&quot;</span><br><span class="line">  if metricDesiredReplicas &gt; desiredReplicas &#123;</span><br><span class="line">   desiredReplicas = metricDesiredReplicas</span><br><span class="line">   rescaleMetric = metricName</span><br><span class="line">  &#125;</span><br><span class="line">  if desiredReplicas &gt; currentReplicas &#123;</span><br><span class="line">   rescaleReason = fmt.Sprintf(&quot;%s above target&quot;, rescaleMetric)</span><br><span class="line">  &#125;</span><br><span class="line">  if desiredReplicas &lt; currentReplicas &#123;</span><br><span class="line">   rescaleReason = &quot;All metrics below target&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  if hpa.Spec.Behavior == nil &#123;</span><br><span class="line">// ④ 对上一步计算出来的期望 pod 副本数做进一步调整以确定最终的期望副本数</span><br><span class="line">   desiredReplicas = a.normalizeDesiredReplicas(hpa, key, currentReplicas, desiredReplicas, minReplicas)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">   desiredReplicas = a.normalizeDesiredReplicasWithBehaviors(hpa, key, currentReplicas, desiredReplicas, minReplicas)</span><br><span class="line">  &#125;</span><br><span class="line">  rescale = desiredReplicas != currentReplicas</span><br><span class="line"> &#125;</span><br><span class="line">// ⑤ 更新目标对象对应的 scale 对象 </span><br><span class="line"> if rescale &#123;  </span><br><span class="line">  scale.Spec.Replicas = desiredReplicas</span><br><span class="line">  _, err = a.scaleNamespacer.Scales(hpa.Namespace).Update(ctx, targetGR, scale, metav1.UpdateOptions&#123;&#125;)</span><br><span class="line">// ...省略部分代码</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">  klog.V(4).Infof(&quot;decided not to scale %s to %v (last scale time was %s)&quot;, reference, desiredReplicas, hpa.Status.LastScaleTime)</span><br><span class="line">  desiredReplicas = currentReplicas</span><br><span class="line"> &#125;</span><br><span class="line">// ⑥ 更新 HPA 对象的状态</span><br><span class="line"> a.setStatus(hpa, currentReplicas, desiredReplicas, metricStatuses, rescale)</span><br><span class="line"> return a.updateStatusIfNeeded(ctx, hpaStatusOriginal, hpa)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数-computeReplicasForMetrics"><a href="#函数-computeReplicasForMetrics" class="headerlink" title="函数 computeReplicasForMetrics"></a>函数 computeReplicasForMetrics</h3><p>根据监控数据度量指标计算期望 pod 副本数。HPA 对象可能关注了多项监控指标数据，对于每一项监控指标都得做相对应的处理，从而评估 pod 容量。</p>
<p>① 将 scale 对象状态中保存的 selector 字段解析为 k8s.io&#x2F;apimachinery&#x2F;pkg&#x2F;labels 包下的 Selector，即标签选择器，用于筛选该 HPA 需要关注的那些 pod 的监控数据度量指标。<br>② 循环遍历 HPA 对象中定义的每一项度量指标规范</p>
<ul>
<li>通过 selector 选择器筛选目标 pod 列表</li>
<li>获取目标 pod 对应的该度量指标数据，与度量指标规范作运算得出相对应的 pod 副本缩放比例，从而计算出该指标下应该当伸缩的 pod 副本数。</li>
<li>取循环过程中产生的最大 pod 副本数，作为返回结果。</li>
</ul>
<p>③ 如果 HPA 对象中定义的所有度量指标在计算过程中皆出现错误时，或者部分指标计算失败，但其余指标计算出的结果可能会导致缩容的情况时，将返回第一次计算失败的错误信息，本次调协不对容量进行调整。其他情况，将对容量进行缩放。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// computeReplicasForMetrics computes the desired number of replicas for the metric specifications listed in the HPA,</span><br><span class="line">// returning the maximum  of the computed replica counts, a description of the associated metric, and the statuses of</span><br><span class="line">// all metrics computed.</span><br><span class="line">func (a *HorizontalController) computeReplicasForMetrics(ctx context.Context, hpa *autoscalingv2.HorizontalPodAutoscaler, scale *autoscalingv1.Scale,</span><br><span class="line"> metricSpecs []autoscalingv2.MetricSpec) (replicas int32, metric string, statuses []autoscalingv2.MetricStatus, timestamp time.Time, err error) &#123;</span><br><span class="line"></span><br><span class="line"> if scale.Status.Selector == &quot;&quot; &#123;</span><br><span class="line">  errMsg := &quot;selector is required&quot;</span><br><span class="line">  a.eventRecorder.Event(hpa, v1.EventTypeWarning, &quot;SelectorRequired&quot;, errMsg)</span><br><span class="line">  setCondition(hpa, autoscalingv2.ScalingActive, v1.ConditionFalse, &quot;InvalidSelector&quot;, &quot;the HPA target&#x27;s scale is missing a selector&quot;)</span><br><span class="line">  return 0, &quot;&quot;, nil, time.Time&#123;&#125;, fmt.Errorf(errMsg)</span><br><span class="line"> &#125;</span><br><span class="line">// ① 标签选择器 selector 用于筛选 pod</span><br><span class="line"> selector, err := labels.Parse(scale.Status.Selector)</span><br><span class="line">// ...省略 err 处理相关代码</span><br><span class="line"> specReplicas := scale.Spec.Replicas</span><br><span class="line"> statusReplicas := scale.Status.Replicas</span><br><span class="line"> statuses = make([]autoscalingv2.MetricStatus, len(metricSpecs))</span><br><span class="line"></span><br><span class="line"> invalidMetricsCount := 0</span><br><span class="line"> var invalidMetricError error</span><br><span class="line"> var invalidMetricCondition autoscalingv2.HorizontalPodAutoscalerCondition</span><br><span class="line">// ② 循环遍历 HPA 对象中定义的每一项度量指标规范</span><br><span class="line"> for i, metricSpec := range metricSpecs &#123;</span><br><span class="line">  replicaCountProposal, metricNameProposal, timestampProposal, condition, err := a.computeReplicasForMetric(ctx, hpa, metricSpec, specReplicas, statusReplicas, selector, &amp;statuses[i])</span><br><span class="line"></span><br><span class="line">  if err != nil &#123;</span><br><span class="line">   if invalidMetricsCount &lt;= 0 &#123;</span><br><span class="line">    invalidMetricCondition = condition</span><br><span class="line">    invalidMetricError = err</span><br><span class="line">   &#125;</span><br><span class="line">   invalidMetricsCount++</span><br><span class="line">  &#125;</span><br><span class="line">// 取循环过程中产生的最大 pod 副本数</span><br><span class="line">  if err == nil &amp;&amp; (replicas == 0 || replicaCountProposal &gt; replicas) &#123;</span><br><span class="line">   timestamp = timestampProposal</span><br><span class="line">   replicas = replicaCountProposal</span><br><span class="line">   metric = metricNameProposal</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> // If all metrics are invalid or some are invalid and we would scale down,</span><br><span class="line"> // return an error and set the condition of the hpa based on the first invalid metric.</span><br><span class="line"> // Otherwise set the condition as scaling active as we&#x27;re going to scale</span><br><span class="line"> if invalidMetricsCount &gt;= len(metricSpecs) || (invalidMetricsCount &gt; 0 &amp;&amp; replicas &lt; specReplicas) &#123;</span><br><span class="line">  setCondition(hpa, invalidMetricCondition.Type, invalidMetricCondition.Status, invalidMetricCondition.Reason, invalidMetricCondition.Message)</span><br><span class="line">  return 0, &quot;&quot;, statuses, time.Time&#123;&#125;, fmt.Errorf(&quot;invalid metrics (%v invalid out of %v), first error is: %v&quot;, invalidMetricsCount, len(metricSpecs), invalidMetricError)</span><br><span class="line"> &#125;</span><br><span class="line"> setCondition(hpa, autoscalingv2.ScalingActive, v1.ConditionTrue, &quot;ValidMetricFound&quot;, &quot;the HPA was able to successfully calculate a replica count from %s&quot;, metric)</span><br><span class="line"> return replicas, metric, statuses, timestamp, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数-computeReplicasForMetric"><a href="#函数-computeReplicasForMetric" class="headerlink" title="函数 computeReplicasForMetric"></a>函数 computeReplicasForMetric</h3><p>计算单个度量指标下期望的 pod 副本数，针对 Metric 的类型分别处理。这里主要介绍<code>Resource</code>类别，<code>ContainerResource</code>与<code>Resource</code>的逻辑较为接近，一个针对 pod 级别的资源使用情况，另一个是针对 pod 内容器级别的资源使用情况。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">func (a *HorizontalController) computeReplicasForMetric(ctx context.Context, hpa *autoscalingv2.HorizontalPodAutoscaler, spec autoscalingv2.MetricSpec,</span><br><span class="line"> specReplicas, statusReplicas int32, selector labels.Selector, status *autoscalingv2.MetricStatus) (replicaCountProposal int32, metricNameProposal string,</span><br><span class="line"> timestampProposal time.Time, condition autoscalingv2.HorizontalPodAutoscalerCondition, err error) &#123;</span><br><span class="line">// 篇幅有限，省略 case 语句中 err 处理相关代码</span><br><span class="line"> switch spec.Type &#123;</span><br><span class="line">// Object 类别</span><br><span class="line"> case autoscalingv2.ObjectMetricSourceType:</span><br><span class="line">  metricSelector, err := metav1.LabelSelectorAsSelector(spec.Object.Metric.Selector)</span><br><span class="line"></span><br><span class="line">  replicaCountProposal, timestampProposal, metricNameProposal, condition, err = a.computeStatusForObjectMetric(specReplicas, statusReplicas, spec, hpa, selector, status, metricSelector)</span><br><span class="line">// Pods 类别</span><br><span class="line"> case autoscalingv2.PodsMetricSourceType:</span><br><span class="line">  metricSelector, err := metav1.LabelSelectorAsSelector(spec.Pods.Metric.Selector)</span><br><span class="line"></span><br><span class="line">  replicaCountProposal, timestampProposal, metricNameProposal, condition, err = a.computeStatusForPodsMetric(specReplicas, spec, hpa, selector, status, metricSelector)</span><br><span class="line">// Resource 类别</span><br><span class="line"> case autoscalingv2.ResourceMetricSourceType:</span><br><span class="line">  replicaCountProposal, timestampProposal, metricNameProposal, condition, err = a.computeStatusForResourceMetric(ctx, specReplicas, spec, hpa, selector, status)</span><br><span class="line">// ContainerResource 类别</span><br><span class="line"> case autoscalingv2.ContainerResourceMetricSourceType:</span><br><span class="line">  replicaCountProposal, timestampProposal, metricNameProposal, condition, err = a.computeStatusForContainerResourceMetric(ctx, specReplicas, spec, hpa, selector, status)</span><br><span class="line">// External 类别</span><br><span class="line"> case autoscalingv2.ExternalMetricSourceType:</span><br><span class="line">  replicaCountProposal, timestampProposal, metricNameProposal, condition, err = a.computeStatusForExternalMetric(specReplicas, statusReplicas, spec, hpa, selector, status)</span><br><span class="line"></span><br><span class="line"> default:</span><br><span class="line">  errMsg := fmt.Sprintf(&quot;unknown metric source type %q&quot;, string(spec.Type))</span><br><span class="line">  err = fmt.Errorf(errMsg)</span><br><span class="line">  condition := a.getUnableComputeReplicaCountCondition(hpa, &quot;InvalidMetricSourceType&quot;, err)</span><br><span class="line">  return 0, &quot;&quot;, time.Time&#123;&#125;, condition, err</span><br><span class="line"> &#125;</span><br><span class="line"> return replicaCountProposal, metricNameProposal, timestampProposal, autoscalingv2.HorizontalPodAutoscalerCondition&#123;&#125;, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="度量指标类型-MetricSourceType"><a href="#度量指标类型-MetricSourceType" class="headerlink" title="度量指标类型 MetricSourceType"></a>度量指标类型 MetricSourceType</h3><p><code>MetricSourceType</code> 常量枚举值的定义如下。<br>代码位于 pkg&#x2F;apis&#x2F;autoscaling&#x2F;types.go</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// MetricSourceType indicates the type of metric.</span><br><span class="line">type MetricSourceType string</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line"> // ObjectMetricSourceType is a metric describing a kubernetes object</span><br><span class="line"> // (for example, hits-per-second on an Ingress object).</span><br><span class="line"> ObjectMetricSourceType MetricSourceType = &quot;Object&quot;</span><br><span class="line"> // PodsMetricSourceType is a metric describing each pod in the current scale</span><br><span class="line"> // target (for example, transactions-processed-per-second).  The values</span><br><span class="line"> // will be averaged together before being compared to the target value.</span><br><span class="line"> PodsMetricSourceType MetricSourceType = &quot;Pods&quot;</span><br><span class="line"> // ResourceMetricSourceType is a resource metric known to Kubernetes, as</span><br><span class="line"> // specified in requests and limits, describing each pod in the current</span><br><span class="line"> // scale target (e.g. CPU or memory).  Such metrics are built in to</span><br><span class="line"> // Kubernetes, and have special scaling options on top of those available</span><br><span class="line"> // to normal per-pod metrics (the &quot;pods&quot; source).</span><br><span class="line"> ResourceMetricSourceType MetricSourceType = &quot;Resource&quot;</span><br><span class="line"> // ContainerResourceMetricSourceType is a resource metric known to Kubernetes, as</span><br><span class="line"> // specified in requests and limits, describing a single container in each pod in the current</span><br><span class="line"> // scale target (e.g. CPU or memory).  Such metrics are built in to</span><br><span class="line"> // Kubernetes, and have special scaling options on top of those available</span><br><span class="line"> // to normal per-pod metrics (the &quot;pods&quot; source).</span><br><span class="line"> ContainerResourceMetricSourceType MetricSourceType = &quot;ContainerResource&quot;</span><br><span class="line"> // ExternalMetricSourceType is a global metric that is not associated</span><br><span class="line"> // with any Kubernetes object. It allows autoscaling based on information</span><br><span class="line"> // coming from components running outside of cluster</span><br><span class="line"> // (for example length of queue in cloud messaging service, or</span><br><span class="line"> // QPS from loadbalancer running outside of cluster).</span><br><span class="line"> ExternalMetricSourceType MetricSourceType = &quot;External&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="函数-computeStatusForResourceMetricGeneric"><a href="#函数-computeStatusForResourceMetricGeneric" class="headerlink" title="函数 computeStatusForResourceMetricGeneric"></a>函数 computeStatusForResourceMetricGeneric</h3><p>计算 <code>Resource</code> 类别度量指标下期望的 pod 副本数。<br>① 处理 HPA 关注的资源平均使用量相关的逻辑。<br>② 处理 HPA 关注的资源平均利用率相关的逻辑。<br>前文示例中的 HPA 对象关注的是 cpu 的平均利用率，下文主要介绍这种情况的处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">func (a *HorizontalController) computeStatusForResourceMetricGeneric(ctx context.Context, currentReplicas int32, target autoscalingv2.MetricTarget,</span><br><span class="line"> resourceName v1.ResourceName, namespace string, container string, selector labels.Selector) (replicaCountProposal int32,</span><br><span class="line"> metricStatus *autoscalingv2.MetricValueStatus, timestampProposal time.Time, metricNameProposal string,</span><br><span class="line"> condition autoscalingv2.HorizontalPodAutoscalerCondition, err error) &#123;</span><br><span class="line">  // ① HPA 关注资源的平均使用量</span><br><span class="line"> if target.AverageValue != nil &#123;</span><br><span class="line">  var rawProposal int64</span><br><span class="line">  replicaCountProposal, rawProposal, timestampProposal, err := a.replicaCalc.GetRawResourceReplicas(ctx, currentReplicas, target.AverageValue.MilliValue(), resourceName, namespace, selector, container)</span><br><span class="line">  if err != nil &#123;</span><br><span class="line">   return 0, nil, time.Time&#123;&#125;, &quot;&quot;, condition, fmt.Errorf(&quot;failed to get %s utilization: %v&quot;, resourceName, err)</span><br><span class="line">  &#125;</span><br><span class="line">  metricNameProposal = fmt.Sprintf(&quot;%s resource&quot;, resourceName.String())</span><br><span class="line">  status := autoscalingv2.MetricValueStatus&#123;</span><br><span class="line">   AverageValue: resource.NewMilliQuantity(rawProposal, resource.DecimalSI),</span><br><span class="line">  &#125;</span><br><span class="line">  return replicaCountProposal, &amp;status, timestampProposal, metricNameProposal, autoscalingv2.HorizontalPodAutoscalerCondition&#123;&#125;, nil</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> if target.AverageUtilization == nil &#123;</span><br><span class="line">  errMsg := &quot;invalid resource metric source: neither a utilization target nor a value target was set&quot;</span><br><span class="line">  return 0, nil, time.Time&#123;&#125;, &quot;&quot;, condition, fmt.Errorf(errMsg)</span><br><span class="line"> &#125;</span><br><span class="line">// ② HPA 关注资源的平均利用率</span><br><span class="line"> targetUtilization := *target.AverageUtilization</span><br><span class="line"> replicaCountProposal, percentageProposal, rawProposal, timestampProposal, err := a.replicaCalc.GetResourceReplicas(ctx, currentReplicas, targetUtilization, resourceName, namespace, selector, container)</span><br><span class="line"> if err != nil &#123;</span><br><span class="line">  return 0, nil, time.Time&#123;&#125;, &quot;&quot;, condition, fmt.Errorf(&quot;failed to get %s utilization: %v&quot;, resourceName, err)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> metricNameProposal = fmt.Sprintf(&quot;%s resource utilization (percentage of request)&quot;, resourceName)</span><br><span class="line"> status := autoscalingv2.MetricValueStatus&#123;</span><br><span class="line">  AverageUtilization: &amp;percentageProposal,</span><br><span class="line">  AverageValue:       resource.NewMilliQuantity(rawProposal, resource.DecimalSI),</span><br><span class="line"> &#125;</span><br><span class="line"> return replicaCountProposal, &amp;status, timestampProposal, metricNameProposal, autoscalingv2.HorizontalPodAutoscalerCondition&#123;&#125;, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数-GetResourceReplicas"><a href="#函数-GetResourceReplicas" class="headerlink" title="函数 GetResourceReplicas"></a>函数 GetResourceReplicas</h3><p>HPA 关注资源的平均利用率，根据给定资源的理想目标资源利用率百分比来计算期望的 pod 副本数。<br>① 通过 MetricsClient 获取 pod 指定资源的度量指标数据。<br>② 根据选择器查询目标 pod 列表。<br>③ 对 pod 进行分组，剔除掉存在噪音干扰因素的 pod 的度量指标数据，这些 pod 的度量指标数据不纳入后续的计算，这些 pod 为：</p>
<ul>
<li>.Status.Phase &#x3D;&#x3D; “Failed” 状态的 pod</li>
<li>pod.DeletionTimestamp !&#x3D; nil 即已删除的 pod</li>
<li>PodCondition 类型 “Ready” 的 status 为 False 的 pod，即未就绪的 pod。PodReady 意味着 Pod 能够处理请求，并且应该添加到所有匹配的 Service 对象的负载均衡列表中。这里即把还不能够提供正常业务能力的 pod 去除，避免干扰计算结果的准确性。</li>
</ul>
<p>④ 统计 pod 对应的该目标资源（如 cpu）请求大小。</p>
<ul>
<li>如果是 pod 维度则统计 pod 中所有容器申请的资源大小累计值。</li>
<li>如果指定了 pod 中某一特定容器名，将仅统计该容器申请的资源大小。</li>
</ul>
<p>⑤ 如果没有获取到 pod 对应资源的度量指标数据，则返回对应的错误信息。<br>⑥ 根据采集的资源度量指标数据、pod 请求的资源大小、HPA 定义的理想状态下资源使用率百分比等计算出实际资源利用率与理想资源利用率的比率（以下称为 <code>usageRatio</code>）等。<br>⑦ 如果不存在缺失监控度量指标数据的 pod ，也不存在 unready 状态的 pod 时：</p>
<ul>
<li>当 usageRatio 在 tolerance 误差范围内，不对容量做缩放，使用原本的副本数。</li>
<li>usageRatio 不在误差范围内，计算缩放后的 pod 副本数并返回。</li>
</ul>
<p>⑧ 当前 usageRatio &lt; 1.0 即表示需要缩容（scale-down）时：</p>
<ul>
<li>令所有缺少了度量指标数据的 pod 的 metric 值为其请求的资源大小，即假设其资源使用率为 100%。</li>
<li>当重新计算 usageRatio 时，不会导致 usageRatio 被进一步缩小从而导致最终计算出的 pod 容量低于实际预期。</li>
</ul>
<p>⑨ 当前 usageRatio &gt; 1.0 即表示需要扩容（scale-up）时：</p>
<ul>
<li>令所有缺少了度量指标数据的 pod 的 metric 值为 0，即假设其资源使用率为 0%。</li>
<li>令所有 unready 状态的 pod 的 metric 值为 0，即假设其资源使用率为 0%。</li>
<li>当重新计算 usageRatio 时，不会导致 usageRatio 被进一步放大从而导致最终计算出的 pod 容量超出实际预期。</li>
</ul>
<p>⑩ 重新计算新的比率 usageRatio。</p>
<ul>
<li>当重新计算的 usageRatio 在误差范围内，不对容量做缩放，使用原本的副本数。</li>
<li>当前后两次计算的资源利用率对应的伸缩行为不一致时，即前一次计算结果为扩容，重新计算结果为缩容，或者前一次计算结果为缩容，重新计算结果为扩容，则使用当前 pod 副本数。</li>
<li>当 usageRatio 与计算得出的期望 pod 副本数表示的伸缩行为一致时，则对 pod 容量进行缩放，否则继续使用当前容量。</li>
</ul>
<p>代码位于 pkg&#x2F;controller&#x2F;podautoscaler&#x2F;replica_calculator.go</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">// GetResourceReplicas calculates the desired replica count based on a target resource utilization percentage</span><br><span class="line">// of the given resource for pods matching the given selector in the given namespace, and the current replica count</span><br><span class="line">func (c *ReplicaCalculator) GetResourceReplicas(ctx context.Context, currentReplicas int32, targetUtilization int32, resource v1.ResourceName, namespace string, selector labels.Selector, container string) (replicaCount int32, utilization int32, rawUtilization int64, timestamp time.Time, err error) &#123;</span><br><span class="line">// 篇幅有限，忽略部分 err 相关处理代码</span><br><span class="line">// ① 获取 pod 的资源度量指标数据</span><br><span class="line"> metrics, timestamp, err := c.metricsClient.GetResourceMetric(ctx, resource, namespace, selector, container)</span><br><span class="line">// ② 根据选择器查询目标 pod 列表</span><br><span class="line"> podList, err := c.podLister.Pods(namespace).List(selector)</span><br><span class="line">// ...</span><br><span class="line"> itemsLen := len(podList)</span><br><span class="line"> if itemsLen == 0 &#123;</span><br><span class="line">  return 0, 0, 0, time.Time&#123;&#125;, fmt.Errorf(&quot;no pods returned by selector while calculating replica count&quot;)</span><br><span class="line"> &#125;</span><br><span class="line">// ③ 对 pod 进行分组</span><br><span class="line">// 1. readyPodCount：准备就绪的 pod</span><br><span class="line">// 2. unreadyPods：未就绪的 pod</span><br><span class="line">// 3. missingPods：缺失度量指标数据的 pod</span><br><span class="line">// 4. ignoredPods 忽略已删除的和 Failed 状态的 pod</span><br><span class="line"> readyPodCount, unreadyPods, missingPods, ignoredPods := groupPods(podList, metrics, resource, c.cpuInitializationPeriod, c.delayOfInitialReadinessStatus)</span><br><span class="line">// ③ 排除忽略的 pod 的度量指标数据</span><br><span class="line"> removeMetricsForPods(metrics, ignoredPods)</span><br><span class="line">// ③ 排除未就绪的 pod 的度量指标数据  </span><br><span class="line"> removeMetricsForPods(metrics, unreadyPods)</span><br><span class="line">// ④ 统计 pod 对应的目标资源（如 cpu）请求大小  </span><br><span class="line"> requests, err := calculatePodRequests(podList, container, resource)</span><br><span class="line">// ...</span><br><span class="line">// ⑤ 没有对应的 pod 度量指标数据，返回相对应的错误。</span><br><span class="line"> if len(metrics) == 0 &#123;</span><br><span class="line">  return 0, 0, 0, time.Time&#123;&#125;, fmt.Errorf(&quot;did not receive metrics for any ready pods&quot;)</span><br><span class="line"> &#125;</span><br><span class="line">// ⑥ 计算出实际资源利用率与理想资源利用率的比率</span><br><span class="line"> usageRatio, utilization, rawUtilization, err := metricsclient.GetResourceUtilizationRatio(metrics, requests, targetUtilization)</span><br><span class="line"> if err != nil &#123;</span><br><span class="line">  return 0, 0, 0, time.Time&#123;&#125;, err</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> rebalanceIgnored := len(unreadyPods) &gt; 0 &amp;&amp; usageRatio &gt; 1.0</span><br><span class="line">// ⑦ 不存在缺失监控度量指标数据的 pod，也不存在 unready 状态的 pod  </span><br><span class="line"> if !rebalanceIgnored &amp;&amp; len(missingPods) == 0 &#123;</span><br><span class="line">// ⑦ 在容错的误差范围内，使用当前的 pod 容量</span><br><span class="line">  if math.Abs(1.0-usageRatio) &lt;= c.tolerance &#123;</span><br><span class="line">   // return the current replicas if the change would be too small</span><br><span class="line">   return currentReplicas, utilization, rawUtilization, timestamp, nil</span><br><span class="line">  &#125;</span><br><span class="line">// ⑦ 向上取整，计算 pod 容量</span><br><span class="line">  // if we don&#x27;t have any unready or missing pods, we can calculate the new replica count no</span><br><span class="line">  return int32(math.Ceil(usageRatio * float64(readyPodCount))), utilization, rawUtilization, timestamp, nil</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> if len(missingPods) &gt; 0 &#123;</span><br><span class="line"> // ⑧ &amp; ⑨ 为缺失监控数据指标的 pod 填充缺省值</span><br><span class="line">  if usageRatio &lt; 1.0 &#123;</span><br><span class="line">   // on a scale-down, treat missing pods as using 100% of the resource request</span><br><span class="line">   for podName := range missingPods &#123;</span><br><span class="line">    metrics[podName] = metricsclient.PodMetric&#123;Value: requests[podName]&#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125; else if usageRatio &gt; 1.0 &#123;</span><br><span class="line">   // on a scale-up, treat missing pods as using 0% of the resource request</span><br><span class="line">   for podName := range missingPods &#123;</span><br><span class="line">    metrics[podName] = metricsclient.PodMetric&#123;Value: 0&#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> // ⑨ 计算结果为扩容时，令未就绪的 pod 的资源利用率为 0%</span><br><span class="line"> if rebalanceIgnored &#123;</span><br><span class="line">  // on a scale-up, treat unready pods as using 0% of the resource request</span><br><span class="line">  for podName := range unreadyPods &#123;</span><br><span class="line">   metrics[podName] = metricsclient.PodMetric&#123;Value: 0&#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">// ⑩ 计算新的比率</span><br><span class="line"> // re-run the utilization calculation with our new numbers</span><br><span class="line"> newUsageRatio, _, _, err := metricsclient.GetResourceUtilizationRatio(metrics, requests, targetUtilization)</span><br><span class="line"> if err != nil &#123;</span><br><span class="line">  return 0, utilization, rawUtilization, time.Time&#123;&#125;, err</span><br><span class="line"> &#125;</span><br><span class="line">// ⑩ 前后两次计算伸缩行为不一致时使用当前 pod 容量</span><br><span class="line"> if math.Abs(1.0-newUsageRatio) &lt;= c.tolerance || (usageRatio &lt; 1.0 &amp;&amp; newUsageRatio &gt; 1.0) || (usageRatio &gt; 1.0 &amp;&amp; newUsageRatio &lt; 1.0) &#123;</span><br><span class="line">  // return the current replicas if the change would be too small,</span><br><span class="line">  // or if the new usage ratio would cause a change in scale direction</span><br><span class="line">  return currentReplicas, utilization, rawUtilization, timestamp, nil</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> newReplicas := int32(math.Ceil(newUsageRatio * float64(len(metrics))))</span><br><span class="line"> if (newUsageRatio &lt; 1.0 &amp;&amp; newReplicas &gt; currentReplicas) || (newUsageRatio &gt; 1.0 &amp;&amp; newReplicas &lt; currentReplicas) &#123;</span><br><span class="line">  // return the current replicas if the change of metrics length would cause a change in scale direction</span><br><span class="line">  return currentReplicas, utilization, rawUtilization, timestamp, nil</span><br><span class="line"> &#125;</span><br><span class="line">// ⑩ 返回计算后的期望 pod 容量大小</span><br><span class="line"> // return the result, where the number of replicas considered is</span><br><span class="line"> // however many replicas factored into our calculation</span><br><span class="line"> return newReplicas, utilization, rawUtilization, timestamp, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数-GetResourceUtilizationRatio"><a href="#函数-GetResourceUtilizationRatio" class="headerlink" title="函数 GetResourceUtilizationRatio"></a>函数 GetResourceUtilizationRatio</h3><p>计算出实际资源利用率与理想资源利用率的比率，进而用于评估 pod 容量。<br/><br>① 累加采集到的 pod 资源度量指标数据之和及它们对应的资源请求值之和。<br/><br>② 计算资源实际使用率百分比。<br/><br>③ 计算出实际资源利用率与理想资源利用率的比率等。<br/><br>代码位于 pkg&#x2F;controller&#x2F;podautoscaler&#x2F;metrics&#x2F;utilization.go</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// GetResourceUtilizationRatio takes in a set of metrics, a set of matching requests,</span><br><span class="line">// and a target utilization percentage, and calculates the ratio of</span><br><span class="line">// desired to actual utilization (returning that, the actual utilization, and the raw average value)</span><br><span class="line">func GetResourceUtilizationRatio(metrics PodMetricsInfo, requests map[string]int64, targetUtilization int32) (utilizationRatio float64, currentUtilization int32, rawAverageValue int64, err error) &#123;</span><br><span class="line"> metricsTotal := int64(0)</span><br><span class="line"> requestsTotal := int64(0)</span><br><span class="line"> numEntries := 0</span><br><span class="line">// ① 累加采集到的 pod 资源度量指标数据之和及它们对应的资源请求值之和</span><br><span class="line"> for podName, metric := range metrics &#123;</span><br><span class="line">  request, hasRequest := requests[podName]</span><br><span class="line">  if !hasRequest &#123;</span><br><span class="line">   // we check for missing requests elsewhere, so assuming missing requests == extraneous metrics</span><br><span class="line">   continue</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  metricsTotal += metric.Value</span><br><span class="line">  requestsTotal += request</span><br><span class="line">  numEntries++</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> // if the set of requests is completely disjoint from the set of metrics,</span><br><span class="line"> // then we could have an issue where the requests total is zero</span><br><span class="line"> if requestsTotal == 0 &#123;</span><br><span class="line">  return 0, 0, 0, fmt.Errorf(&quot;no metrics returned matched known pods&quot;)</span><br><span class="line"> &#125;</span><br><span class="line">// ② 计算资源实际使用率百分比</span><br><span class="line"> currentUtilization = int32((metricsTotal * 100) / requestsTotal)</span><br><span class="line">// ③ 计算出实际资源利用率和理想资源利用率的比率等</span><br><span class="line"> return float64(currentUtilization) / float64(targetUtilization), currentUtilization, metricsTotal / int64(numEntries), nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="运用伸缩行为规则"><a href="#运用伸缩行为规则" class="headerlink" title="运用伸缩行为规则"></a>运用伸缩行为规则</h3><p>对根据监控数据度量指标计算出来的期望 pod 副本数做进一步调整以确定最终的期望副本数。</p>
<ul>
<li>未指定<code>.spec.behavior</code>字段时，运用默认的行为规则。</li>
<li>当指定<code>.spec.behavior</code>字段时，运用指定的行为规则。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 上文代码回顾， HPA 调协逻辑</span><br><span class="line">func (a *HorizontalController) reconcileAutoscaler(ctx context.Context, hpaShared *autoscalingv2.HorizontalPodAutoscaler, key string) error &#123;</span><br><span class="line">// ...</span><br><span class="line">  if hpa.Spec.Behavior == nil &#123; // 未指定`.spec.behavior`字段时，运用默认的 HPAScalingRules</span><br><span class="line">   desiredReplicas = a.normalizeDesiredReplicas(hpa, key, currentReplicas, desiredReplicas, minReplicas)</span><br><span class="line">  &#125; else &#123; // 运用指定的行为规则</span><br><span class="line">   desiredReplicas = a.normalizeDesiredReplicasWithBehaviors(hpa, key, currentReplicas, desiredReplicas, minReplicas)</span><br><span class="line">  &#125;</span><br><span class="line">  rescale = desiredReplicas != currentReplicas</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数-normalizeDesiredReplicas"><a href="#函数-normalizeDesiredReplicas" class="headerlink" title="函数 normalizeDesiredReplicas"></a>函数 normalizeDesiredReplicas</h3><p>未指定<code>.spec.behavior</code>字段时，运用默认的行为规则。<br>① 取稳定时间窗口内的最大推荐 pod 副本数。时间窗口默认大小为 5min，可通过 controller manager 启动参数<code>--horizontal-pod-autoscaler-downscale-stabilization</code>指定。<br>② 容量不得低于 HPA 指定的最小值，也不得高于 HPA 指定的最大值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">func (a *HorizontalController) normalizeDesiredReplicas(hpa *autoscalingv2.HorizontalPodAutoscaler, key string, currentReplicas int32, prenormalizedDesiredReplicas int32, minReplicas int32) int32 &#123;</span><br><span class="line">// </span><br><span class="line"> stabilizedRecommendation := a.stabilizeRecommendation(key, prenormalizedDesiredReplicas)</span><br><span class="line">// ...省略代码</span><br><span class="line"> desiredReplicas, condition, reason := convertDesiredReplicasWithRules(currentReplicas, stabilizedRecommendation, minReplicas, hpa.Spec.MaxReplicas)</span><br><span class="line">// ...省略代码</span><br><span class="line"> return desiredReplicas</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">// ① 取稳定时间窗口内的最大推荐容量</span><br><span class="line">func (a *HorizontalController) stabilizeRecommendation(key string, prenormalizedDesiredReplicas int32) int32 &#123;</span><br><span class="line"> maxRecommendation := prenormalizedDesiredReplicas</span><br><span class="line"> foundOldSample := false</span><br><span class="line"> oldSampleIndex := 0</span><br><span class="line"> cutoff := time.Now().Add(-a.downscaleStabilisationWindow)</span><br><span class="line"> for i, rec := range a.recommendations[key] &#123;</span><br><span class="line">  if rec.timestamp.Before(cutoff) &#123;</span><br><span class="line">   foundOldSample = true</span><br><span class="line">   oldSampleIndex = i</span><br><span class="line">  &#125; else if rec.recommendation &gt; maxRecommendation &#123;</span><br><span class="line">   maxRecommendation = rec.recommendation</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">// 替换旧的推荐容量大小  </span><br><span class="line"> if foundOldSample &#123; </span><br><span class="line">  a.recommendations[key][oldSampleIndex] = timestampedRecommendation&#123;prenormalizedDesiredReplicas, time.Now()&#125;</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">  a.recommendations[key] = append(a.recommendations[key], timestampedRecommendation&#123;prenormalizedDesiredReplicas, time.Now()&#125;)</span><br><span class="line"> &#125;</span><br><span class="line"> return maxRecommendation</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line"> scaleUpLimitFactor  = 2.0</span><br><span class="line"> scaleUpLimitMinimum = 4.0</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func calculateScaleUpLimit(currentReplicas int32) int32 &#123;</span><br><span class="line"> return int32(math.Max(scaleUpLimitFactor*float64(currentReplicas), scaleUpLimitMinimum))</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">// convertDesiredReplicas performs the actual normalization, without depending on `HorizontalController` or `HorizontalPodAutoscaler`</span><br><span class="line">func convertDesiredReplicasWithRules(currentReplicas, desiredReplicas, hpaMinReplicas, hpaMaxReplicas int32) (int32, string, string) &#123;</span><br><span class="line"></span><br><span class="line"> var minimumAllowedReplicas int32</span><br><span class="line"> var maximumAllowedReplicas int32</span><br><span class="line"></span><br><span class="line"> var possibleLimitingCondition string</span><br><span class="line"> var possibleLimitingReason string</span><br><span class="line"></span><br><span class="line"> minimumAllowedReplicas = hpaMinReplicas</span><br><span class="line"></span><br><span class="line"> // Do not upscale too much to prevent incorrect rapid increase of the number of master replicas caused by</span><br><span class="line"> // bogus CPU usage report from heapster/kubelet (like in issue #32304).</span><br><span class="line"> scaleUpLimit := calculateScaleUpLimit(currentReplicas)</span><br><span class="line">// 限制本次扩容 pod 副本数上限，避免 pod 副本数过快增长</span><br><span class="line"> if hpaMaxReplicas &gt; scaleUpLimit &#123;</span><br><span class="line">  maximumAllowedReplicas = scaleUpLimit</span><br><span class="line">  possibleLimitingCondition = &quot;ScaleUpLimit&quot;</span><br><span class="line">  possibleLimitingReason = &quot;the desired replica count is increasing faster than the maximum scale rate&quot;</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">  maximumAllowedReplicas = hpaMaxReplicas</span><br><span class="line">  possibleLimitingCondition = &quot;TooManyReplicas&quot;</span><br><span class="line">  possibleLimitingReason = &quot;the desired replica count is more than the maximum replica count&quot;</span><br><span class="line"> &#125;</span><br><span class="line">// ② 容量不得低于 HPA 指定的最小值，也不得高于 HPA 指定的最大值</span><br><span class="line"> if desiredReplicas &lt; minimumAllowedReplicas &#123;</span><br><span class="line">  possibleLimitingCondition = &quot;TooFewReplicas&quot;</span><br><span class="line">  possibleLimitingReason = &quot;the desired replica count is less than the minimum replica count&quot;</span><br><span class="line"></span><br><span class="line">  return minimumAllowedReplicas, possibleLimitingCondition, possibleLimitingReason</span><br><span class="line"> &#125; else if desiredReplicas &gt; maximumAllowedReplicas &#123;</span><br><span class="line">  return maximumAllowedReplicas, possibleLimitingCondition, possibleLimitingReason</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> return desiredReplicas, &quot;DesiredWithinRange&quot;, &quot;the desired count is within the acceptable range&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，已经介绍完了 HPA 的整体逻辑。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>HPA 大致处理逻辑为：</p>
<ol>
<li>根据 HPA 对象的定义，读取与容量伸缩相关的 Pod 监控指标。</li>
<li>根据当前指标数据和 HPA 中定义的理想指标值评估 Pod 容量。</li>
</ol>
<p>用公式表示如下：</p>
<p>$$期望Pod副本数 &#x3D; \lceil\frac{当前指标值}{理想指标值} × 当前副本数\rceil$$</p>
<p>期望副本数当前指标值理想指标值当前副本数</p>
<p>感谢阅读，水平有限，难免出错，欢迎指正。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1]《Kubernetes 设计模式》: <em>弹性伸缩</em></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Gtechdigi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/09/06/Kubernetes-pod/">http://example.com/2022/09/06/Kubernetes-pod/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Gtech</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Kubernetes/">Kubernetes</a><a class="post-meta__tags" href="/tags/pod/">pod</a></div><div class="post_share"><div class="social-share" data-image="https://www.gtechdigi.cn/favicon.ico" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/01/09/Udo/" title="搞了一个数据质量监控软件"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">搞了一个数据质量监控软件</div></div></a></div><div class="next-post pull-right"><a href="/2022/08/29/Sonic/" title="Sonic设备管理平台使用分享"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Sonic设备管理平台使用分享</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://www.gtechdigi.cn/favicon.ico" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Gtechdigi</div><div class="author-info__description">以消费者为中心，以技术为驱动，满足多行业数字化融合需求。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/GTechdigi"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/GTechdigi" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#highlight-vs2015"><span class="toc-number">1.</span> <span class="toc-text">highlight: vs2015</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Pod-%E6%89%8B%E5%8A%A8%E6%B0%B4%E5%B9%B3%E4%BC%B8%E7%BC%A9"><span class="toc-number">2.1.</span> <span class="toc-text">Pod 手动水平伸缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pod-%E8%87%AA%E5%8A%A8%E6%B0%B4%E5%B9%B3%E4%BC%B8%E7%BC%A9"><span class="toc-number">2.2.</span> <span class="toc-text">Pod 自动水平伸缩</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MetricsClient"><span class="toc-number">3.</span> <span class="toc-text">MetricsClient</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MetricsClient-%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89"><span class="toc-number">3.1.</span> <span class="toc-text">MetricsClient 接口定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-metrics-%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">3.2.</span> <span class="toc-text">创建 metrics 客户端</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HorizontalController"><span class="toc-number">4.</span> <span class="toc-text">HorizontalController</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-HPA-%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">4.1.</span> <span class="toc-text">创建 HPA 控制器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8-HPA-%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">4.2.</span> <span class="toc-text">启动 HPA 控制器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0-woker"><span class="toc-number">4.3.</span> <span class="toc-text">函数 woker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0-reconcileKey"><span class="toc-number">4.4.</span> <span class="toc-text">函数 reconcileKey</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0-reconcileAutoscaler"><span class="toc-number">4.5.</span> <span class="toc-text">函数 reconcileAutoscaler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0-computeReplicasForMetrics"><span class="toc-number">4.6.</span> <span class="toc-text">函数 computeReplicasForMetrics</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0-computeReplicasForMetric"><span class="toc-number">4.7.</span> <span class="toc-text">函数 computeReplicasForMetric</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%A6%E9%87%8F%E6%8C%87%E6%A0%87%E7%B1%BB%E5%9E%8B-MetricSourceType"><span class="toc-number">4.8.</span> <span class="toc-text">度量指标类型 MetricSourceType</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0-computeStatusForResourceMetricGeneric"><span class="toc-number">4.9.</span> <span class="toc-text">函数 computeStatusForResourceMetricGeneric</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0-GetResourceReplicas"><span class="toc-number">4.10.</span> <span class="toc-text">函数 GetResourceReplicas</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0-GetResourceUtilizationRatio"><span class="toc-number">4.11.</span> <span class="toc-text">函数 GetResourceUtilizationRatio</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%94%A8%E4%BC%B8%E7%BC%A9%E8%A1%8C%E4%B8%BA%E8%A7%84%E5%88%99"><span class="toc-number">4.12.</span> <span class="toc-text">运用伸缩行为规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0-normalizeDesiredReplicas"><span class="toc-number">4.13.</span> <span class="toc-text">函数 normalizeDesiredReplicas</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">小结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">5.1.</span> <span class="toc-text">参考资料</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/10/OpenTelemetry-javaagent/" title="OpenTelemetry javaagent 类加载器">OpenTelemetry javaagent 类加载器</a><time datetime="2023-05-10T09:56:17.000Z" title="发表于 2023-05-10 17:56:17">2023-05-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/07/Jetpack-Compose/" title="Jetpack Compose初体验">Jetpack Compose初体验</a><time datetime="2023-04-07T09:55:11.000Z" title="发表于 2023-04-07 17:55:11">2023-04-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/31/FlutterBoost-in-IOS/" title="iOS工程调用Flutter篇（FlutterBoost框架）">iOS工程调用Flutter篇（FlutterBoost框架）</a><time datetime="2023-03-31T09:54:07.000Z" title="发表于 2023-03-31 17:54:07">2023-03-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/30/Flutter-in-IOS/" title="iOS工程内嵌Flutter篇">iOS工程内嵌Flutter篇</a><time datetime="2023-03-30T09:53:21.000Z" title="发表于 2023-03-30 17:53:21">2023-03-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/30/FlutterBoost-in-Android/" title="Android工程调用Flutter篇（FlutterBoost框架）">Android工程调用Flutter篇（FlutterBoost框架）</a><time datetime="2023-03-30T09:52:14.000Z" title="发表于 2023-03-30 17:52:14">2023-03-30</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Gtechdigi</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>